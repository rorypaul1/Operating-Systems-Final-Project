<style type="text/css">.rendered-markdown{font-size:14px} .rendered-markdown>*:first-child{margin-top:0!important} .rendered-markdown>*:last-child{margin-bottom:0!important} .rendered-markdown a{text-decoration:underline;color:#b75246} .rendered-markdown a:hover{color:#f36050} .rendered-markdown h1, .rendered-markdown h2, .rendered-markdown h3, .rendered-markdown h4, .rendered-markdown h5, .rendered-markdown h6{margin:24px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased;cursor:text;position:relative} .rendered-markdown h1 tt, .rendered-markdown h1 code, .rendered-markdown h2 tt, .rendered-markdown h2 code, .rendered-markdown h3 tt, .rendered-markdown h3 code, .rendered-markdown h4 tt, .rendered-markdown h4 code, .rendered-markdown h5 tt, .rendered-markdown h5 code, .rendered-markdown h6 tt, .rendered-markdown h6 code{font-size:inherit} .rendered-markdown h1{font-size:28px;color:#000} .rendered-markdown h2{font-size:22px;border-bottom:1px solid #ccc;color:#000} .rendered-markdown h3{font-size:18px} .rendered-markdown h4{font-size:16px} .rendered-markdown h5{font-size:14px} .rendered-markdown h6{color:#777;font-size:14px} .rendered-markdown p, .rendered-markdown blockquote, .rendered-markdown ul, .rendered-markdown ol, .rendered-markdown dl, .rendered-markdown table, .rendered-markdown pre{margin:15px 0} .rendered-markdown hr{border:0 none;color:#ccc;height:4px;padding:0} .rendered-markdown>h2:first-child, .rendered-markdown>h1:first-child, .rendered-markdown>h1:first-child+h2, .rendered-markdown>h3:first-child, .rendered-markdown>h4:first-child, .rendered-markdown>h5:first-child, .rendered-markdown>h6:first-child{margin-top:0;padding-top:0} .rendered-markdown a:first-child h1, .rendered-markdown a:first-child h2, .rendered-markdown a:first-child h3, .rendered-markdown a:first-child h4, .rendered-markdown a:first-child h5, .rendered-markdown a:first-child h6{margin-top:0;padding-top:0} .rendered-markdown h1+p, .rendered-markdown h2+p, .rendered-markdown h3+p, .rendered-markdown h4+p, .rendered-markdown h5+p, .rendered-markdown h6+p{margin-top:0} .rendered-markdown ul, .rendered-markdown ol{padding-left:30px} .rendered-markdown ul li>:first-child, .rendered-markdown ul li ul:first-of-type, .rendered-markdown ol li>:first-child, .rendered-markdown ol li ul:first-of-type{margin-top:0} .rendered-markdown ul ul, .rendered-markdown ul ol, .rendered-markdown ol ol, .rendered-markdown ol ul{margin-bottom:0} .rendered-markdown dl{padding:0} .rendered-markdown dl dt{font-size:14px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px} .rendered-markdown dl dt:first-child{padding:0} .rendered-markdown dl dt>:first-child{margin-top:0} .rendered-markdown dl dt>:last-child{margin-bottom:0} .rendered-markdown dl dd{margin:0 0 15px;padding:0 15px} .rendered-markdown dl dd>:first-child{margin-top:0} .rendered-markdown dl dd>:last-child{margin-bottom:0} .rendered-markdown blockquote{border-left:4px solid #DDD;padding:0 15px;color:#777} .rendered-markdown blockquote>:first-child{margin-top:0} .rendered-markdown blockquote>:last-child{margin-bottom:0} .rendered-markdown table th{font-weight:bold} .rendered-markdown table th, .rendered-markdown table td{border:1px solid #ccc;padding:6px 13px} .rendered-markdown table tr{border-top:1px solid #ccc;background-color:#fff} .rendered-markdown table tr:nth-child(2n){background-color:#f8f8f8} .rendered-markdown img{max-width:100%;-moz-box-sizing:border-box;box-sizing:border-box} .rendered-markdown code, .rendered-markdown tt{margin:0 2px;padding:0 5px;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px} .rendered-markdown code{white-space:nowrap} .rendered-markdown pre>code{margin:0;padding:0;white-space:pre;border:0;background:transparent} .rendered-markdown .highlight pre, .rendered-markdown pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px} .rendered-markdown pre code, .rendered-markdown pre tt{margin:0;padding:0;background-color:transparent;border:0}</style>
<div class="rendered-markdown"><h1>Parallel Sort</h1>
<p>Sorting, or alphabetizing as you called it as a child, is still a critical task for data-intensive applications, including databases, spreadsheets, and many other data-oriented applications. In this project, you'll be building a high-performance parallel sort.</p>
<p>There are three specific objectives to this assignment:</p>
<p>To familiarize yourself with the Linux pthreads.
<br  />To learn how to parallelize a program.
<br  />To learn how to program for high performance.</p>
<p><strong>Background</strong>
<br  />To understand how to make progress on any project that involves concurrency,
<br  />you should understand the basics of thread creation, mutual
<br  />exclusion (with locks), and signaling/waiting (with condition variables).
<br  />These are described in the following topics:</p>
<p>Intro to Threads
<br  />Threads API
<br  />Locks
<br  />Using Locks
<br  />Condition Variables
<br  />Read these chapters carefully in order to prepare yourself for this project.</p>
<p><strong>Project Specification</strong>
<br  />Your parallel sort (psort) will take two command-line arguments.</p>
<p>prompt> ./psort input output
<br  />The input file will consist of records; within each record is a key. The key is the first four bytes of the record. The records are fixed-size, and are each 100 bytes (which includes the key).</p>
<p>A successful sort will read all the records into memory from the input file, sort them, and then write them out to the output file.</p>
<p>You also have to force writes to disk by calling fsync() on the output file before finishing.</p>
<p>You can assume that this is a one-pass sort, i.e., the data can fit into memory. You do not have to implement a multi-pass sort.</p>
<p><strong>Considerations</strong>
<br  />Doing so effectively and with high performance will require you to address (at least) the following issues:</p>
<p>How to parallelize the sorting. Of course, the central challenge of this project is to parallelize the sorting process. Think about what can be done in parallel, and what must be done serially by a single thread, and design your parallel sort as appropriate.</p>
<p>One interesting issue that the &ldquo;best&rdquo; implementations will handle is this: what happens if one thread runs more slowly than another? Does the sort give more work to faster threads?</p>
<p>How to determine how many threads to create. On Linux, this means using interfaces like get_nprocs() and get_nprocs_conf(); read the man pages for more details. Then, create threads to match the number of CPU resources available.</p>
<p>How to efficiently perform each piece of work. While parallelization will yield speed up, each thread's efficiency in performing the sorting is also of critical importance. You can glean some hints from papers like the famous AlphaSort paper.</p>
<p>How to access the input/output files efficiently. On Linux, there are many ways to read from a file, including C standard library calls like fread() and raw system calls like read(). One particularly efficient way is to use memory-mapped files, available via mmap(). By mapping the input file into the address space, you can then access bytes of the input file via pointers and do so quite efficiently. Similarly, how you write the output, and perhaps, how you overlap writing with sorting, can make your sort run faster.</p>
<p><strong>Grading</strong>
<br  />Your code should compile (and should be compiled) with the following flags: -Wall -Werror -pthread -O. The last one is important: it turns on the optimizer! In fact, for fun, try timing your code with and without -O and marvel at the difference.</p>
<p>Your code will first be measured for correctness, ensuring that it sorts input files correctly.</p>
<p>If you pass the correctness tests, your code will be tested for performance; higher performance will lead to better scores. The fastest sort will be declared the &ldquo;fastest sorter&rdquo; and appropriate awards will be given.</p>
</div>